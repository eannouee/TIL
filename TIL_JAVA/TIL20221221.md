# 2022.12.21 복습 
> 부족한 개념 복습 정리 

---

## Set Collection

저장 순서를 저장하는 List Collection과 달리 Set Collection은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없고 하나의 null만 저장할 수 있다.

### HashSet
< 생성 방법 >
```Java
Set<E> set = new HashSet<E>(); //E에 지정된 타입의 객체만 저장
Set<E> set = new HashSet<>(); //E에 지정된 타입의 객체만 저장 
Set set = new HashSet(); //모든 타입의 객체를 저장 
```
타입 파라미터 E에는 HashSet에 저장하고 싶은 객체 타입을 지정하면 된다. Set에 지정한 객체 타입과 동일하다면 HashSet<>과 같이 객체 타입을 생략할 수 있다. 객체 타입을 모두 생략하면 모든 종류의 객체를 저장할 수 있다.
- HastSet은 동일한 객체는 중복 저장하지 않는다. (동일한 객체란 동등 객체를 의미)
- 다른 객체라도 hashCode() 메소드의 리턴값이 같고, equals() 메소드가 true를 리턴하면 동일한 객체라고 판단하고 중복저장하지 않는다.
- 문자열을 저장할 경우, 같은 문자열을 갖는 String 객체는 동등한 객체로 간주한다.

Set Collection은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 대신 객체를 한 개씩 반복해서 가져와야 한다.
-   1. for문 사용
```Java
Set<E> set = new HashSet<>();
for(E e : set){
    ...
}
```
- 2. iterator(반복자) 사용
  - boolean hasNext() : 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴
  - E   next() : 컬렉션에서 하나의 객체를 가져옴 
  - void    remove() : next()로 가져온 객체를 Set 컬렉션을 제거

```Java
Set<E> set = new HashSet<>();
Iterator<E> iterator = set.iterator();
```
  ---

  ## Map Collection
  Map Collecttion은 키(key)와 값(value)으로 구성된 엔트리(entry) 객체를 저장한다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장할 수 없지만 값은 중복 저장할 수 있다. 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대치된다.

  Map Collection에는 키를 매개값으로 갖는 메소드가 많은데 그 이유는 키로 객체를 관리하기 때문이다.

< 메소드 > 직관적인 것은 정리하지 않았다.
- V put<K key, V value> : 주어진 키와 값을 추가, 저장이 되면 값을 리턴
- Set<Map.Entry<K,V>> entrySet() : 키와 값의 쌍으로 구성된 모든 Map.Entry 객체를 Set에 담아서 리턴 
- Set<K> keySet() : 모든 키를 Set 객체에 담아서 리턴 
- Collection<V> values() : 저장된 모든 값 Collection에 담아서 리턴 

여기서 K는 key를 의미, V는 value를 의미

### HashMap
키로 사용할 객체가 hashCode() 메소드의 리턴값이 같고 equals() 메소드가 true를 리턴할 경우, 동일 키로 보고 중복 저장을 허용하지 않는다.

키는 String 타입, 값은 Integer 타입으로 갖는 HashMap은 다음과 같이 생성할 수 있다. Map에 지정된 키와 타입이 HashMap과 동일할 경우, HashMap<>을 사용할 수 있다.
```Java
Map<String, Integer> map = new HashMap<String, Integer>
```

### Hashtable
HashMap과 동일한 내부 구조를 가지고 있다. 차이점은 Hashtable은 동기화된(synchronized) 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 Hashtable의 메소드들을 실행할 수 없다는 것이다. 따랄서 멀티 스레드 환경에서도 안전하게 객체를 추가, 삭제할 수 있다.

  


   
  
