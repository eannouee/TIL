# 2023.01.04 JavaScript 복습 정리

## Type(추가 정리)
### 자바스크립트 타입들의 boolean 변환
- 조건식에서 활용될 경우 false가 되는 값들 : 0, ''(공백), null, undefined, NaN(not a number)
- 조건식에서 활용될 경우 true가 되는 값들 : false가 되는 경우를 제외한 모두

## Operator
1. 연산자
- 산술 : + - * / %
- 단항 : ++ --
- 비교 : > < >= <= == != === !==
- 논리 : && ||
- 삼항 : 조건식?값1:값2
- 문자열 결합 : +

2. 동등연산자와 일치연산자
- == : type을 추론하여 casting 한 다음 casting된 값으로 비교연산을 수행
- === : type과 같이 정확하게 일치해야만 true

-> 정확한 타입을 알면 일치 연산자를 사용하면 되지만, 때때로 타입 추론을 해야할 경우(타입을 모를 경우) 동등 연산자를 사용하기도 함 그레서 둘 중 뭘 사용해라라고 확언하기는 어려움(그래도 비교적 정확한 일치연산자 ===를 많이 사용)

## Statement
자바스크립트의 statement
- if
- switch
- while
- for 
- forEach

## Array
배열, 자바스크립트에서 모든 타입의 데이터를 저장하는 자료구조
- index를 사용해 저장된 배열의 요소에 접근이 가능하다
- 자바의 Object List와 유사하다(제네릭없는)
- slice : 원본 배열을 변경시키지 않고 원하는 위치의 배열요소를 복제하는 메소드
- flatmap : 일차원 배열은 평탄화를 해줌, 다차원은 자기 기준 한차원만 평탄화 진행
- reduce : 이전 횟차의 callback 함수가 반환한 return 값을 다음 회차의 acc 매개변수로 전달 

## Exception
자바스크립트의 예외처리
- try-catch-finally 블록을 사용할 수 있다
- Error 클래스를 상속 받아 custom Error를 만들 수 있다
- 요소객체에 접근하는 코드가 있는 script 태그는 Html body 태그 안의 최하단에 작성하는 것이 좋다
- 스크립트 태그가 errorNote가 랜더링 되기 전에 스크립트코드가 먼저 실행되어서 errorNote 요소객체를 가져올 수 없다 -> 에러 발생 

## Function
자바스크립트의 Function은 1급객체이다.
- 1급객체라는 것은 값으로 다루어질 수 있는 객체(자바의 Object)를 의미한다
- 값 : 변수에 할당될 수 있다, 매개변수로 전달될 수 있다, 반환값으로 사용될 수 있다 (함수가)

1. 함수 선언식
- function fnc(a,b){}
- 함수 선언으로 만들어진 함수는 호이스팅이 발생한다

2. 함수 표현식
- let hello = function(){} -> 이름이 없는 익명함수를 넣어줌
- 함수를 선언하지 않고 함수를 생성해 변수에 할당하는 방식
- 자바스크립트의 함수는 1급객체이기 때문에 가능한 방식
- 함수표현식을 사용하면 호이스팅이 발생하지 않는다(let과 var랑 상관없이)
- 따라서 함수표현식을 사용할 것을 권장

3. 화살표 함수(람다 표현식)
- 작성구문
    1. 화살표 함수 : () => {함수 작성 블록}
    2. 만약 매개변수가 하나라면 괄호를 생략 가능
    3. 만약 함수에 리턴문만 존재한다면 return과 {}를 생략 가능

4. 즉시 실행 함수 표현식(Imeediately Invoked Function Expresstion)
- 함수를 정의함과 동시에 실행하는 함수
- 즉시 실행 함수는 다시 호출 할 수 없다
- 최초 한 번만 실행되어야 하는 초기화 코드에 많이 사용

<가장 대표적인 iife 사용방식>
``` Javascript      
(function(){
    let message = '함수가 실행 됩니다.';
    iifeNote.innerHTML += message;

})();
```

5. 자바스크립트의 interpreter가 함수표현식과 함수 선언식을 구분하는 방법 
- 라인의 첫 단어가 function이면 함수 선언식으로 구분
- 라인의 첫 단어가 function이 아닌데, 뒤에 function과 관련된 코드가 있으면 함수표현식으로 구분
- 함수 선언식은 선언과 동시에 실행이 불가능
- 아래 코드는 불가능한 코드다
``` Javascript      
function test(){
    console.dir('a');
}();
```
- 함수 표현식은 생성과 동시에 실행이 가능
``` Javascript      
let str = function(){return 'hi'}();
console.dir(str);
```
- 첫 단어가 (function이기 때문에 함수 표현식으로 인터프리터가 인지해서 즉시 실행 가능
 ``` Javascript      
(function(){
    let message = '함수가 실행 됩니다.';
    iifeNote.innerHTML += message;
})();
```
- 이렇게 해도 가능(모든 특수기호가 다 되는 것은 아님)
``` Javascript      
!function(){
    let message = '함수가 실행 됩니다.';
    iiNote.innerHTML += message;
}();
```
6. 함수를 return 하기
 ``` Javascript      
let plus = function(){
    return function(a, b){
        returnNote.innerHTML += a+b;
    }
}

let res = plus();
res(10,20);
```

7. Lexical Scope
함수의 상위 스코프가 함수가 선언(생성)되는 시점에 결정되는 것
- 함수 내부에서 함수의 상위 스코프에 있는 변수에는 접근할 수 있지만
- 함수의 상위 스코프에 존재하지 않는 변수에는 접근할 수 없다
- 만약 상위 스코프에 같은 이름의 변수가 여러개 존재한다면 가까운 상위 스코프의 변수를 사용한다
- 자바스크립트의 함수는 생성될 때, 자신이 생성되는 시점의 환경(자신의 상위 스코프, 상위 스코프에 선언된 변수들)를 기억한다
- 상위 스코프에도 변수가 없으면 undefined를 반환
  
8. Closuer
실행이 종료된 함수의 지역변수를 참조하기 위해 사용하는 함수 생성 방식
* 함수는 생성되는 시점에 스코프체인을 통해 자신의 상위 스코프를 기억한다
* 자바스크립트의 heap 영역의 데이터들도 자바와 마찬가지로 더이상 객체를 참조하고 있는 변수가 없을 때 가비지 컬렉터에 의해서 메모리에서 삭제된다
- 바깥 함수가 안 쪽 함수를 리턴하면 바깥쪽 함수는 안 쪽 함수의 상위스코프이기 때문에 바깥쪽 함수의 지역, 매개변수를 안 쪽 함수가 자신의 스코프체인을 통해 기억하고 있다
- 바깥 함수의 실행이 종료되더라도 안 쪽 함수의 스코프체인을 통해 바깥 함수의 지역변수에 접근 가능하다
  
8. 함수의 매개변수
- 자바스크립트의 함수에 선언된 매개변수들에 함수를 실행할 때 전달인자를 전달하지 않아도 호출이 가능하다
- 자바스크립트 함수의 전달인자들은 arguments 객체에 저장되는 방식이기 때문이다
  





