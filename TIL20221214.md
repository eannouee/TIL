# Abstract Class
> 2022.12.14 부족한 부분 개념 정리

---

## 추상 클래스
>사전적 의미로 추상(abstract)은 실체 간의 공통되는 특성을 추출한 것이다.

추상 클래스는 추상 메소드가 0개 이상 존재하는 클래스이다. \
추상 메소드가 존재한다면 반드시 추상 클래스로 만들어야 한다. \
추상 클래스는 미완의 클래스이기 때문에 인스턴스화가 불가능하다. \ 
추상 클래스를 상속받은 자식 클래스는 추상 메소드를 Override 함으로써 추상 클래스를 완성시킨다.


### 추상메소드
abstract : 미완의, 추상의 \
Figure 클래스를 상속받는 클래스에서는 반드시 calArea 메소드를 Override 해야만 한다. 

도형마다 넓이를 구하는 공식이 있지만 그 공식의 내용은 모두 다르기 때문에 Figure 클래스를 상속받는 모든 자식 클래스에서 규칙을 재정의하도록 강제한다. 


### @Override
부모 클래스로부터 상속받은 메소드를 재정의 

#override : Override 어노테이션(annotation) 

annotation : 클래스가 컴파일 되기 전에 수행되어야 하는 기능을 정의 

# Interface
> 서로 다른 시스템이 결합되기 위해 지켜야하는 약속 

인터페이스는 인터페이스를 구현하는 모든 클래스들이 지켜야하는 공통의 규약이다.

인터페이스 -> 클래스 : 구현
인터페이스 -> 인터페이스 : 상속(다중상속 가능)

인터페이스의 구현은 추상 클래스의 상속과 마찬가지로 추상 메소드에 대한 구현과 타입을 물려준다. 

인터페이스끼리의 상속은 다중상속이 가능하다.

- 인터페이스의 필드변수는 묵시적으로 public static final이다.
    - 다시 말해서 인스턴스의 변수가 아니라는 것, 즉 변경이 불가능하다.
- 인터페이스의 인스턴스 메소드는 묵시적으로 public static 메소드이다.
  -  private는 자바 9버전부터 사용이 가능
  -  자바 8버전 이후로 default 도입 
         - 인터페이스 내에서 구현부를 가진 인스턴스 메소드를 허용

implements : 인터페이스 구현

# 중첩 선언과 익명 객체
## 중첩 클래스 
> 중첩 클래스(Nested Class)란 클래스 내부에 선언한 클래스를 의미

선언하는 위치에 따라 두 가지로 분류되는데, 
- 클래스의 멤버로서 건언되는 중첩 클래스를 멤버 클래스
- 메소드 내부에서 선언되는 중첩 클래스를 로컬 클래스 
  
ex) 멤버 클래스 - 인스턴스 멤버 클래스

객체 생성 조건 : A 객체를 생성해야만 B 객체를 생성할 수 있음

```Java
class A{
    class B{}
}
```

ex) 멤버 클래스 - 정적 멤버 클래스

객체 생성 조건 : A 객체를 생성하지 않아도 B 객체를 생성할 수 있음
```Java
class A{
   static class B{}
}
```
ex) 로컬 클래스 

객체 생성 조건 : 메소드가 실행할 때만 B 객체를 생성할 수 있음 
```Java
class A{
   void method(){
    class B{}
   }
}
```

## 인스턴스 멤버 클래스
ex) 다음과 같이 A 클래스의 멤버로 선언된 B 클래스를 의미
```Java
public class A{
    public / private class B{ // 인스턴스 멤버 클래스 

    } 
}
```

<접근 제한자에 따른 인스턴스 멤버 클래스의 접근 범위>

public class B{} : 다른 패키지에서 B 클래스를 사용할 수 있다.

class B{} : 같은 패키지에서만 B 클래스를 사용할 수 있다.

private class B{} : A 클래스 내부에서만 B 클래스를 사용할 수 있다.

인스턴스 멤버 클래스 B는 주로 A 클래스 내부에서 사용되므로 private 접근 제한자를 갖는 것이 일반적이다. B 객체는 A 클래스 어디에서나 생성할 수는 없고, 인스턴스 필드값, 생성자, 인스턴스 메소드에서 생성 가능하다. A 객체가 있어야 B 객체도 생성할 수 있기 때문이다.
-  B 객체를 A 클래스 외부에 생성하려면 default 또는 public 접근 제한자를 가져야 하고, A 객체를 먼저 생성한 다음 B 객체를 생성해야 한다.
  - 인스턴스 멤버 클래스 B 내부에는 일반 클래스와 같이 필드, 생성자, 메소드 선언이 올 수 있다. 
      - 정적 필드와 정적 메소드는 Java 17부터 선언이 가능하다.         


## 정적 멤버 클래스
ex) 정적 멤버 클래스는 다음과 같이 static 키워드와 함께 A 클래스의 멤버로 선언된 B 클래스를 말한다.
```Java
public class A{
    public / private static class B{ // 정적 멤버 클래스 

    } 
}
```

<접근 제한자에 따른 인스턴스 멤버 클래스의 접근 범위>

public static class B{} : 다른 패키지에서 B 클래스를 사용할 수 있다.

static class B{} : 같은 패키지에서만 B 클래스를 사용할 수 있다.

private static class B{} : A 클래스 내부에서만 B 클래스를 사용할 수 있다.

정적 멤버 클래스 B는 A 클래스 내부에서 사용되기도 하지만, A 클래스 외부에서 A와 함께 사용되는 경우가 많기 때문에 주로 default 또는 public 접근 제한자를 가진다. B 객체는 A 클래스 내부 어디든 객체를 생성할 수 있다. 
- A 클래스 외부에서 B 객체를 생성하려면 A 객체 생성 없이 A 클래스로 접근하여 B 객체를 생성할 수 있다.
- 정적 멤버 클래스 B 내부에는 일반 클래스와 같이 필드, 생성자, 메소드 선언이 올 수 있다.

## 로컬 클래스
생성자 또는 메소드 내부에서 다음과 같이 선언된 클래스를 로컬(Local) 클래스라 한다.

```Java
public class A{
    public A(){
        class B{} //로컬 클래스
    }
   public void method(){
    class B{} //로컬 클래스 
   }
} 
```

로컬 클래스는 생성자와 메소드가 실행될 동안에만 객체를 생성할 수 있다.

- 로컬 변수(생성자 또는 매개변수 또는 내부에서 선언된 변수)를 로컬 클래스에서 사용할 경우 로컬 변수는 final 특성을 갖게 되므로 값을 읽을 수만 있고 수정할 수 없게 된다. 이것은 로컬 클래스 내부에서 값을 변경하지 못하도록 제한하기 때문이다.
  - java 8이후부터는 명시적으로 final 키워드를 붙이지 않아도 되지만 로컬 변수에 final 키워드를 추가해서 final 변수임을 명확히 할 수도 있다.





